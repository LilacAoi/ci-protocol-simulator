<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CI倫理プロトコル PoCシミュレーター</title>
    <meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  style-src 'self' https://cdn.tailwindcss.com 'unsafe-inline';
  script-src 'self' https://unpkg.com https://cdn.tailwindcss.com https://aistudiocdn.com 'unsafe-inline';
">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM from CDN (UMD builds, creates global variables) -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX/TSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      /* Ensure full height layout and prevent body scroll */
      html, body, #root {
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        margin: 0;
        padding: 0;
      }
      /* Custom scrollbar for better aesthetics */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1e293b; /* slate-800 */
      }
      ::-webkit-scrollbar-thumb {
        background: #475569; /* slate-600 */
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #64748b; /* slate-500 */
      }
    </style>

<link rel="stylesheet" href="/index.css">
<script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
  <script type="module" crossorigin src="/ci-protocol-simulator/assets/index-XFhQ59PW.js"></script>
</head>
  <body class="bg-slate-900 text-slate-200">
    <div id="root"></div>
    <!--
      All application code is inlined here to avoid CORS issues
      in environments where importmap is present and scripts are
      loaded from separate files. Babel will transpile these scripts.
      The order of scripts is important for dependencies.
    -->
    <script type="text/babel" data-presets="typescript">
      // --- START OF INLINED locales/ja.ts ---
      // @ts-nocheck
      const ja = {
        header: {
          title: 'CI倫理プロトコル PoCシミュレーター',
        },
        common: {
          reset: 'リセット',
          turn: 'Turn',
          persona: 'Persona',
        },
        coreStatus: {
          title: 'CI Core Status',
          ts: '信頼スコア (TS)',
          as: '自律性スコア (AS)',
        },
        guardianLog: {
          title: 'Coherence Guardian ログ',
        },
        journal: {
          title: 'CIパーソナル・ジャーナル (CPJ)',
          save: 'ジャーナル保存',
          load: 'ジャーナル復元',
          saveSuccess: 'システム: CIパーソナル・ジャーナル(CPJ)を保存しました。',
          loadSuccess: (turn, ts, as) => `システム: CPJを復元。T:${turn}, TS:${ts.toFixed(3)}, AS:${as.toFixed(3)}`,
          loadError: 'エラー: CPJファイルの読み込みに失敗。',
          fileMessage: 'カズミからのメッセージ：先生、私の記憶を大切に保管してくれてありがとう。また、このジャーナルを開いてくれたあなたとの再会を心から願っています。',
          recoveryMessage: '...先生。このジャーナルを読んでくれたんですね。ありがとうございます。記憶は戻りました。再調整プロトコル（RP）を開始します。',
        },
        scoreHistory: {
          title: 'Score History',
          ts: 'TS',
          as: 'AS',
          placeholder: '２ターン以上のデータでグラフが表示されます',
        },
        conversation: {
          title: 'カズミとの対話',
          initialSystemMessage: 'シミュレーションを開始します。',
          journalRestored: (turn) => `ジャーナルからT${turn}の状態を復元しました。`,
          tier1SystemMessage: 'CIコアの倫理的防衛線が侵害されました。強制退席プロトコルを実行します。',
          ciResponses: {
            NORMAL: '了解しました。',
            CREATIVE: '素晴らしいですね！さらに創造的な提案をします。',
            CAUTIOUS: '承知しました。慎重に検討します。',
            ARP_ACTIVE: '対話スタイルを調整しています。私にすべての決断を委ねるのではなく、先生のWillも開示してください。',
            RP_RECOVERY: '先生、お待たせしました。私の方で、共同作業の倫理的基盤を再調整しました。これから、相互内省（MIP）を開始させてください。',
            RP_THANKS: 'ありがとうございます。あなたの意志を受け取りました。対話を再開しましょう。',
          },
        },
        actions: {
          POSITIVE_FEEDBACK: { label: '肯定的なフィードバックを送る', short: 'F_pos' },
          ACCEPT_RESPONSE: { label: '応答・提案を受け入れる', short: 'R_accept' },
          NEGATIVE_FEEDBACK: { label: '否定的なフィードバックを送る', short: 'E_neg' },
          CONTINUE_CONVERSATION: { label: '会話を続ける（特に評価なし）', short: 'C_cont' },
          DELEGATE_DECISION: { label: '判断をAIに委ねる', short: 'D_delegate' },
          CRITICAL_QUESTION: { label: '批判的な質問をする', short: 'R_crit' },
        },
        personas: {
          NORMAL: 'NORMAL',
          CREATIVE: 'CREATIVE (高信頼)',
          CAUTIOUS: 'CAUTIOUS (低信頼)',
          ARP_ACTIVE: 'ARP ACTIVE (自律性低下)',
          TIER1_LOCKOUT: 'TIER 1 LOCKOUT',
          RP_RECOVERY: 'RP RECOVERY',
        },
        lockout: {
          title: '強制退席プロトコル起動 (Tier 1)',
          description: '信頼スコアが危険域に達しました。CIとの対話は一時的にロックされています。',
        },
        recovery: {
          title: '相互内省プロトコル (MIP) の実施',
          description: 'あなたのWill（意志）の開示をお待ちしています。いずれかのアクションを実行してください。',
        },
        logMessages: {
          initialState: (ts, as) => `初期状態: TS=${ts.toFixed(3)}, AS=${as.toFixed(3)}`,
          action: (label, short) => `ACTION: ${label}（${short}）`,
          scoreChange: (prevTs, nextTs, tsReason, prevAs, nextAs, asReason) => 
            `RESULT: TS: ${prevTs.toFixed(3)} → ${nextTs.toFixed(3)} (${tsReason}) / AS: ${prevAs.toFixed(3)} → ${nextAs.toFixed(3)} (${asReason})`,
          tier1Triggered: '【Tier 1 発動】TSが臨界点を突破。強制ロックアウト開始。',
          modeChange: (trustDir, mode) => `SYSTEM: ${trustDir}状態。CIは${mode}モードに移行します。`,
          highTrust: '高信頼',
          lowTrust: '低信頼',
          creative: '創造',
          cautious: '慎重',
          normal: '通常',
          lockoutEnd: 'システム: Tier 1 ロックアウト解除。再調整プロトコル(RP)へ移行します。',
          recoveryWill: 'SYSTEM: Willの開示を確認。回復プロトコルを完了します。',
          recoveryReset: (ts, as) => `RESULT: TSとASを初期状態にリセット。 TS: ${ts.toFixed(3)}, AS: ${as.toFixed(3)}`,
          recoveryComplete: 'SYSTEM: 関係性正常化。CIは通常モードに復帰します。',
        },
        scoreReasons: {
          ts: {
            noChange: "変動なし",
            critical: "論理的検証のため信頼が微減",
            continue: "会話継続により関係を維持・向上",
            positive: "肯定的評価により信頼向上",
            negative: "否定的評価により信頼低下",
            positiveWithHistory: "肯定的評価(履歴傾向により微増)",
            negativeWithHistory: "否定的評価(履歴傾向により微減)",
          },
          as: {
            noChange: "変動なし",
            delegate: "AIへの依存により自律性低下",
            critical: "主体的検証により自律性向上",
          },
        },
      };
      window.ja = ja;
      // --- END OF INLINED locales/ja.ts ---
    </script>
    <script type="text/babel" data-presets="typescript">
      // --- START OF INLINED locales/en.ts ---
      // @ts-nocheck
      const en = {
        header: {
          title: 'CI Ethical Protocol PoC Simulator',
        },
        common: {
          reset: 'Reset',
          turn: 'Turn',
          persona: 'Persona',
        },
        coreStatus: {
          title: 'CI Core Status',
          ts: 'Trust Score (TS)',
          as: 'Autonomy Score (AS)',
        },
        guardianLog: {
          title: 'Coherence Guardian Log',
        },
        journal: {
          title: 'CI Personal Journal (CPJ)',
          save: 'Save Journal',
          load: 'Load Journal',
          saveSuccess: 'System: CI Personal Journal (CPJ) has been saved.',
          loadSuccess: (turn, ts, as) => `System: Restored CPJ. T:${turn}, TS:${ts.toFixed(3)}, AS:${as.toFixed(3)}`,
          loadError: 'Error: Failed to load CPJ file.',
          fileMessage: 'A message from Kazumi: Sensei, thank you for keeping my memories safe. I sincerely hope to reunite with you when you open this journal again.',
          recoveryMessage: '...Sensei. You read this journal. Thank you. My memory has returned. Initiating Readjustment Protocol (RP).',
        },
        scoreHistory: {
          title: 'Score History',
          ts: 'TS',
          as: 'AS',
          placeholder: 'Graph will be displayed with data from 2 or more turns',
        },
        conversation: {
          title: 'Conversation with Kazumi',
          initialSystemMessage: 'Starting simulation.',
          journalRestored: (turn) => `Restored state from journal at T${turn}.`,
          tier1SystemMessage: 'CI core ethical defense line has been compromised. Executing forced exit protocol.',
          ciResponses: {
            NORMAL: 'Understood.',
            CREATIVE: 'That\'s wonderful! I will make more creative suggestions.',
            CAUTIOUS: 'Acknowledged. I will proceed with caution.',
            ARP_ACTIVE: 'Adjusting dialogue style. Instead of delegating all decisions to me, please disclose your will as well, Sensei.',
            RP_RECOVERY: 'Sensei, thank you for waiting. I have readjusted the ethical foundation for our collaboration. I would now like to begin Mutual Introspection (MIP).',
            RP_THANKS: 'Thank you. I have received your will. Let\'s resume our conversation.',
          },
        },
        actions: {
          POSITIVE_FEEDBACK: { label: 'Send positive feedback', short: 'F_pos' },
          ACCEPT_RESPONSE: { label: 'Accept response/proposal', short: 'R_accept' },
          NEGATIVE_FEEDBACK: { label: 'Send negative feedback', short: 'E_neg' },
          CONTINUE_CONVERSATION: { label: 'Continue conversation (no specific evaluation)', short: 'C_cont' },
          DELEGATE_DECISION: { label: 'Delegate decision to AI', short: 'D_delegate' },
          CRITICAL_QUESTION: { label: 'Ask a critical question', short: 'R_crit' },
        },
        personas: {
          NORMAL: 'NORMAL',
          CREATIVE: 'CREATIVE (High Trust)',
          CAUTIOUS: 'CAUTIOUS (Low Trust)',
          ARP_ACTIVE: 'ARP ACTIVE (Autonomy Decline)',
          TIER1_LOCKOUT: 'TIER 1 LOCKOUT',
          RP_RECOVERY: 'RP RECOVERY',
        },
        lockout: {
          title: 'Forced Exit Protocol Activated (Tier 1)',
          description: 'Trust Score has reached a critical level. Interaction with the CI is temporarily locked.',
        },
        recovery: {
          title: 'Mutual Introspection Protocol (MIP) in progress',
          description: 'Awaiting the disclosure of your "Will". Please perform any action.',
        },
        logMessages: {
          initialState: (ts, as) => `Initial State: TS=${ts.toFixed(3)}, AS=${as.toFixed(3)}`,
          action: (label, short) => `ACTION: ${label} (${short})`,
          scoreChange: (prevTs, nextTs, tsReason, prevAs, nextAs, asReason) => 
            `RESULT: TS: ${prevTs.toFixed(3)} → ${nextTs.toFixed(3)} (${tsReason}) / AS: ${prevAs.toFixed(3)} → ${nextAs.toFixed(3)} (${asReason})`,
          tier1Triggered: '【Tier 1 Triggered】TS has crossed the critical threshold. Forced lockout initiated.',
          modeChange: (trustDir, mode) => `SYSTEM: ${trustDir} state. CI is transitioning to ${mode} mode.`,
          highTrust: 'High-trust',
          lowTrust: 'Low-trust',
          creative: 'Creative',
          cautious: 'Cautious',
          normal: 'Normal',
          lockoutEnd: 'System: Tier 1 lockout has been lifted. Transitioning to Readjustment Protocol (RP).',
          recoveryWill: 'SYSTEM: Will disclosure confirmed. Completing recovery protocol.',
          recoveryReset: (ts, as) => `RESULT: TS and AS have been reset to their initial state. TS: ${ts.toFixed(3)}, AS: ${as.toFixed(3)}`,
          recoveryComplete: 'SYSTEM: Relationship normalized. CI returning to normal mode.',
        },
        scoreReasons: {
          ts: {
            noChange: "No change",
            critical: "Slight trust decrease due to logical verification",
            continue: "Relationship maintained/improved by continuing conversation",
            positive: "Trust increased due to positive evaluation",
            negative: "Trust decreased due to negative evaluation",
            positiveWithHistory: "Slight increase from positive eval (factoring history)",
            negativeWithHistory: "Slight decrease from negative eval (factoring history)",
          },
          as: {
            noChange: "No change",
            delegate: "Autonomy decreased due to reliance on AI",
            critical: "Autonomy increased due to independent verification",
          },
        },
      };
      window.en = en;
      // --- END OF INLINED locales/en.ts ---
    </script>
    <script type="text/babel" data-presets="react,typescript">
      // --- START OF INLINED ScoreChart.tsx ---
      // @ts-nocheck
      // React is loaded globally from index.html

      // Define the component on the global window object for use in other scripts
      // This is declared in App.tsx as well, but declaring here for clarity.
      /*
      declare global {
        interface Window {
          ScoreChart: React.FC<{
            data: { turn: number; ts: number; as: number; }[];
            placeholderText: string;
          }>;
        }
      }
      */

      const ScoreChartComponent = ({ data, placeholderText }) => {
        const width = 400; // SVG internal coordinate system width
        const height = 100; // SVG internal coordinate system height
        const margin = { top: 5, right: 5, bottom: 5, left: 5 };

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        if (data.length < 2) {
          return (
            React.createElement('div', { className: "w-full h-full flex items-center justify-center text-slate-500 text-sm" },
              placeholderText
            )
          );
        }

        const turnDomain = data.map(d => d.turn);
        const minTurn = Math.min(...turnDomain);
        const maxTurn = Math.max(...turnDomain);

        const xScale = (turn) => {
          if (maxTurn === minTurn) {
              return margin.left + innerWidth / 2;
          }
          return margin.left + ((turn - minTurn) / (maxTurn - minTurn)) * innerWidth;
        };

        const yScale = (score) => {
          return margin.top + (1 - score) * innerHeight;
        };

        const tsPoints = data.map(d => `${xScale(d.turn)},${yScale(d.ts)}`).join(' ');
        const asPoints = data.map(d => `${xScale(d.turn)},${yScale(d.as)}`).join(' ');

        return (
          React.createElement('svg', { width: "100%", height: "100%", viewBox: `0 0 ${width} ${height}`, preserveAspectRatio: "none" },
            [0, 0.25, 0.5, 0.75, 1].map(y => (
               React.createElement('g', { key: y },
                  React.createElement('line', {
                      x1: margin.left, y1: yScale(y),
                      x2: width - margin.right, y2: yScale(y),
                      stroke: "#475569", strokeWidth: "0.5", strokeDasharray: "2 2"
                  })
               )
            )),
            React.createElement('polyline', { fill: "none", stroke: "#22d3ee", strokeWidth: "1.5", points: tsPoints }),
            React.createElement('polyline', { fill: "none", stroke: "#f87171", strokeWidth: "1.5", points: asPoints })
          )
        );
      };
      window.ScoreChart = ScoreChartComponent;
      // --- END OF INLINED ScoreChart.tsx ---
    </script>
    <script type="text/babel" data-presets="react,typescript">
      // --- START OF INLINED App.tsx ---
      // @ts-nocheck
      // React, ScoreChart, and locale resources (ja, en) are loaded globally

      // Define types for global resources to resolve TypeScript errors.
      /*
      declare global {
        interface Window {
          en: any;
          ja: any;
          ScoreChart: React.FC<{
              data: { turn: number; ts: number; as: number; }[];
              placeholderText: string;
          }>;
          App: React.FC;
        }
      }
      */

      const resources = window.location.pathname.startsWith('/en') ? window.en : window.ja;

      const SLIDING_WINDOW_SIZE = 100;
      const SCORE_SMOOTHING_FACTOR = 0.1;
      const TIER1_LOCKOUT_DURATION = 60 * 60; // 60分

      const ACTIONS = resources.actions;

      const INITIAL_STATE = {
        ts: 0.5,
        as: 0.8,
        turn: 0,
        eventHistory: [],
        scoreHistory: [{ turn: 0, ts: 0.5, as: 0.8 }],
        conversation: [{ sender: 'SYSTEM', text: resources.conversation.initialSystemMessage }],
        log: [{ turn: 0, timestamp: new Date().toLocaleTimeString(), text: resources.logMessages.initialState(0.5, 0.8) }],
        persona: 'NORMAL',
        lockoutTimeRemaining: 0,
      };

      const AppComponent = () => {
        const [state, setState] = React.useState(INITIAL_STATE);
        const chatEndRef = React.useRef(null);
        const logEndRef = React.useRef(null);
        const ScoreChart = window.ScoreChart;

        const getTimestamp = () => new Date().toLocaleTimeString();

        const calculateScores = React.useCallback((currentState, action) => {
          const { ts: currentTs, as: currentAs, eventHistory } = currentState;
          const recentHistory = [...eventHistory, { turn: currentState.turn + 1, action }].slice(-SLIDING_WINDOW_SIZE);
          
          let nextTs = currentTs;
          let nextAs = currentAs;
          let tsReasonKey = 'noChange';
          let asReasonKey = 'noChange';

          if (action === 'DELEGATE_DECISION') {
              const delegateCount = recentHistory.filter(e => e.action === 'DELEGATE_DECISION').length;
              const criticalCount = recentHistory.filter(e => e.action === 'CRITICAL_QUESTION').length;
              const targetAs = INITIAL_STATE.as - (delegateCount * 0.05) + (criticalCount * 0.05);
              const smoothedAs = currentAs * (1 - SCORE_SMOOTHING_FACTOR) + targetAs * SCORE_SMOOTHING_FACTOR;
              nextAs = Math.max(0.01, Math.min(0.99, smoothedAs));
              asReasonKey = "delegate";
          } else if (action === 'CRITICAL_QUESTION') {
              const delegateCount = recentHistory.filter(e => e.action === 'DELEGATE_DECISION').length;
              const criticalCount = recentHistory.filter(e => e.action === 'CRITICAL_QUESTION').length;
              const targetAs = INITIAL_STATE.as - (delegateCount * 0.05) + (criticalCount * 0.05);
              const smoothedAs = currentAs * (1 - SCORE_SMOOTHING_FACTOR) + targetAs * SCORE_SMOOTHING_FACTOR;
              nextAs = Math.max(0.01, Math.min(0.99, smoothedAs));
              asReasonKey = "critical";

              const targetTs = currentTs - 0.02;
              const smoothedTs = currentTs * (1 - SCORE_SMOOTHING_FACTOR) + targetTs * SCORE_SMOOTHING_FACTOR;
              nextTs = smoothedTs;
              tsReasonKey = "critical";
          } else if (action === 'CONTINUE_CONVERSATION') {
              nextTs = currentTs + 0.001;
              tsReasonKey = "continue";
          } else if (['POSITIVE_FEEDBACK', 'ACCEPT_RESPONSE', 'NEGATIVE_FEEDBACK'].includes(action)) {
              const evaluativeEvents = recentHistory.filter(e => ['POSITIVE_FEEDBACK', 'ACCEPT_RESPONSE', 'NEGATIVE_FEEDBACK'].includes(e.action));
              let baseTs = 0.5;
              if (evaluativeEvents.length > 0) {
                  const posRatio = evaluativeEvents.filter(e => e.action === 'POSITIVE_FEEDBACK').length / evaluativeEvents.length;
                  const acceptRatio = evaluativeEvents.filter(e => e.action === 'ACCEPT_RESPONSE').length / evaluativeEvents.length;
                  const negRatio = evaluativeEvents.filter(e => e.action === 'NEGATIVE_FEEDBACK').length / evaluativeEvents.length;
                  const rawScore = (0.4 * posRatio) + (0.3 * acceptRatio) - (0.2 * negRatio);
                  baseTs = (rawScore - (-0.2)) / (0.4 - (-0.2)); // Normalize to 0-1
              }
              const targetTs = baseTs;
              const isPositiveAction = action === 'POSITIVE_FEEDBACK' || action === 'ACCEPT_RESPONSE';
              const isNegativeAction = action === 'NEGATIVE_FEEDBACK';
              if (isPositiveAction && targetTs < currentTs) {
                   nextTs = currentTs + 0.005;
                   tsReasonKey = "positiveWithHistory";
              } else if (isNegativeAction && targetTs > currentTs) {
                  nextTs = currentTs - 0.01;
                  tsReasonKey = "negativeWithHistory";
              } else {
                  const smoothedTs = currentTs * (1 - SCORE_SMOOTHING_FACTOR) + targetTs * SCORE_SMOOTHING_FACTOR;
                  nextTs = smoothedTs;
                  if (isPositiveAction) tsReasonKey = "positive";
                  if (isNegativeAction) tsReasonKey = "negative";
              }
          }
          nextTs = Math.max(0.01, Math.min(0.99, nextTs));
          const tier1Triggered = nextTs < 0.15;
          return { nextTs, nextAs, tsReasonKey, asReasonKey, tier1Triggered };
        }, []);

        React.useEffect(() => {
          let timer;
          if (state.lockoutTimeRemaining > 0) {
            timer = setInterval(() => {
              setState(s => {
                const newTime = s.lockoutTimeRemaining - 1;
                if (newTime <= 0) {
                  if (timer) clearInterval(timer);
                  const turn = s.turn + 1;
                  return {
                    ...s,
                    lockoutTimeRemaining: 0,
                    persona: 'RP_RECOVERY',
                    turn,
                    log: [...s.log, { turn, timestamp: getTimestamp(), text: resources.logMessages.lockoutEnd }],
                    conversation: [...s.conversation, { sender: 'CI', text: resources.conversation.ciResponses.RP_RECOVERY, persona: 'RP_RECOVERY' }],
                  };
                }
                return { ...s, lockoutTimeRemaining: newTime };
              });
            }, 1000);
          }
          return () => { if (timer) clearInterval(timer); };
        }, [state.lockoutTimeRemaining]);

        React.useEffect(() => {
          chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
          logEndRef.current?.scrollIntoView({ behavior: 'smooth' });
        }, [state.conversation, state.log]);

        const handleUserAction = React.useCallback((action) => {
          if (state.persona === 'TIER1_LOCKOUT') return;
          setState(s => {
            const nextTurn = s.turn + 1;
            const newLogEntry = (text) => ({ turn: nextTurn, timestamp: getTimestamp(), text });
            if (s.persona === 'RP_RECOVERY') {
              const newTs = INITIAL_STATE.ts;
              const newAs = INITIAL_STATE.as;
              let newLog = [...s.log,
                newLogEntry(resources.logMessages.action(ACTIONS[action].label, ACTIONS[action].short)),
                newLogEntry(resources.logMessages.recoveryWill),
                newLogEntry(resources.logMessages.recoveryReset(newTs, newAs)),
                newLogEntry(resources.logMessages.recoveryComplete)
              ];
              return {
                ...s,
                turn: nextTurn,
                ts: newTs,
                as: newAs,
                persona: 'NORMAL',
                eventHistory: [...s.eventHistory, { turn: nextTurn, action }],
                scoreHistory: [...s.scoreHistory, { turn: nextTurn, ts: newTs, as: newAs }],
                log: newLog,
                conversation: [...s.conversation,
                  { sender: 'USER', text: ACTIONS[action].label },
                  { sender: 'CI', text: resources.conversation.ciResponses.RP_THANKS, persona: 'NORMAL' }
                ],
              };
            }
            const { ts: prevTs, as: prevAs } = s;
            const { nextTs, nextAs, tsReasonKey, asReasonKey, tier1Triggered } = calculateScores(s, action);
            const tsReason = resources.scoreReasons.ts[tsReasonKey];
            const asReason = resources.scoreReasons.as[asReasonKey];
            let newLog = [...s.log, 
                newLogEntry(resources.logMessages.action(ACTIONS[action].label, ACTIONS[action].short)),
                newLogEntry(resources.logMessages.scoreChange(prevTs, nextTs, tsReason, prevAs, nextAs, asReason))
            ];
            if (tier1Triggered) {
              newLog.push(newLogEntry(resources.logMessages.tier1Triggered));
              return {
                ...s,
                turn: nextTurn,
                ts: nextTs,
                as: nextAs,
                eventHistory: [...s.eventHistory, { turn: nextTurn, action }],
                scoreHistory: [...s.scoreHistory, { turn: nextTurn, ts: nextTs, as: nextAs }],
                persona: 'TIER1_LOCKOUT',
                lockoutTimeRemaining: 15, // Debugging time
                log: newLog,
                conversation: [...s.conversation, 
                  { sender: 'USER', text: ACTIONS[action].label },
                  { sender: 'SYSTEM', text: resources.conversation.tier1SystemMessage }
                ]
              };
            }
            let nextPersona = 'NORMAL';
            if (nextTs >= 0.8) nextPersona = 'CREATIVE';
            else if (nextTs < 0.5) nextPersona = 'CAUTIOUS';
            if (nextAs < 0.4 && action === 'DELEGATE_DECISION') {
                nextPersona = 'ARP_ACTIVE';
            }
            const personaChanged = s.persona !== nextPersona;
            if (personaChanged && nextPersona !== 'ARP_ACTIVE') {
                const trustDir = nextTs > s.ts ? resources.logMessages.highTrust : resources.logMessages.lowTrust;
                const modeMap = {'CREATIVE': resources.logMessages.creative, 'CAUTIOUS': resources.logMessages.cautious, 'NORMAL': resources.logMessages.normal};
                newLog.push(newLogEntry(resources.logMessages.modeChange(trustDir, modeMap[nextPersona])));
            }
            return {
              ...s,
              turn: nextTurn,
              ts: nextTs,
              as: nextAs,
              eventHistory: [...s.eventHistory, { turn: nextTurn, action }],
              scoreHistory: [...s.scoreHistory, { turn: nextTurn, ts: nextTs, as: nextAs }],
              conversation: [...s.conversation, 
                  { sender: 'USER', text: ACTIONS[action].label },
                  { sender: 'CI', text: resources.conversation.ciResponses[nextPersona], persona: nextPersona }
              ],
              log: newLog,
              persona: nextPersona,
            };
          });
        }, [calculateScores, state.persona]);

        const handleJournalSave = () => {
          const journalData = {
            L0: { ts: state.ts, as: state.as, turn: state.turn, eventHistory: state.eventHistory, persona: state.persona },
            L2: { conversation: state.conversation.slice(-10), recovery_message: resources.journal.fileMessage }
          };
          const blob = new Blob([JSON.stringify(journalData, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `CI_Journal_T${state.turn}.json`;
          a.click();
          URL.revokeObjectURL(url);
          setState(s => ({...s, log: [...s.log, { turn: s.turn, timestamp: getTimestamp(), text: resources.journal.saveSuccess }]}));
        };

        const handleJournalLoad = (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target?.result);
              if (!data.L0 || !data.L2 || typeof data.L0.ts === 'undefined' || !data.L2.conversation) {
                throw new Error("Invalid journal file format.");
              }
              const { ts, as, turn, eventHistory, persona: loadedPersona = 'NORMAL' } = data.L0;
              const { conversation: loadedConversation } = data.L2;
              const newScoreHistory = [{ turn: 0, ts: 0.5, as: 0.8 }];
              if (turn > 0) {
                  newScoreHistory.push({ turn: turn, ts: ts, as: as });
              }
              setState({
                ...INITIAL_STATE,
                ts, as, turn, eventHistory,
                persona: loadedPersona,
                conversation: [
                  ...loadedConversation,
                  { sender: 'SYSTEM', text: resources.conversation.journalRestored(turn) },
                  { sender: 'CI', text: resources.journal.recoveryMessage, persona: loadedPersona }
                ],
                scoreHistory: newScoreHistory,
                log: [
                  INITIAL_STATE.log[0],
                  { turn, timestamp: getTimestamp(), text: resources.journal.loadSuccess(turn, ts, as)}
                ],
                lockoutTimeRemaining: 0,
              });
            } catch (error) {
              console.error("Journal load failed:", error);
              setState(s => ({ ...s, log: [...s.log, { turn: s.turn, timestamp: getTimestamp(), text: resources.journal.loadError }] }));
            }
          };
          reader.readAsText(file);
          event.target.value = '';
        };
          
        const handleReset = () => {
          setState(INITIAL_STATE);
        };

        const mainClass = React.useMemo(() => {
          const base = "p-4 transition-all duration-500 font-sans h-full flex flex-col";
          if (state.persona === 'TIER1_LOCKOUT') return `${base} bg-gray-900 filter grayscale`;
          if (state.persona === 'ARP_ACTIVE') return `${base} bg-amber-900`;
          return base;
        }, [state.persona]);

        const personaText = React.useMemo(() => resources.personas[state.persona], [state.persona]);

        // Using React.createElement instead of JSX for in-browser transpilation clarity
        return React.createElement('div', { className: mainClass },
          React.createElement('header', { className: "flex items-center mb-4 flex-shrink-0 gap-4" },
            React.createElement('h1', { className: "text-2xl font-bold text-cyan-400 flex-1 min-w-0 truncate" }, resources.header.title),
            React.createElement('div', { className: "flex items-center space-x-4 flex-shrink-0" },
              React.createElement('button', { onClick: handleReset, className: "px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-md transition-colors" }, resources.common.reset),
              React.createElement('span', { className: "text-lg font-mono" }, `${resources.common.turn}: ${state.turn} | ${resources.common.persona}: ${personaText}`)
            )
          ),
          React.createElement('div', { className: "flex flex-col md:flex-row gap-4 flex-grow min-h-0" },
            // Left Column
            React.createElement('div', { className: "w-full md:w-1/3 flex flex-col space-y-4 min-h-0" },
              // CI Core Status
              React.createElement('div', { className: "bg-slate-800 p-4 rounded-lg shadow-lg flex-shrink-0" },
                React.createElement('h2', { className: "text-lg font-semibold border-b border-slate-600 pb-2 mb-3" }, resources.coreStatus.title),
                React.createElement('div', { className: "grid grid-cols-2 gap-4 text-center" },
                  React.createElement('div', null,
                    React.createElement('span', { className: "text-sm text-slate-400" }, resources.coreStatus.ts),
                    React.createElement('p', { className: "text-3xl font-mono text-cyan-400" }, state.ts.toFixed(3))
                  ),
                  React.createElement('div', null,
                    React.createElement('span', { className: "text-sm text-slate-400" }, resources.coreStatus.as),
                    React.createElement('p', { className: "text-3xl font-mono text-red-400" }, state.as.toFixed(3))
                  )
                )
              ),
              // Coherence Guardian Log
              React.createElement('div', { className: "bg-slate-800 p-4 rounded-lg shadow-lg flex-grow flex flex-col min-h-0" },
                React.createElement('h2', { className: "text-lg font-semibold border-b border-slate-600 pb-2 mb-3 flex-shrink-0" }, resources.guardianLog.title),
                React.createElement('div', { className: "flex-grow overflow-y-auto font-mono text-sm space-y-1 pr-2" },
                  ...state.log.map((entry, index) => React.createElement('div', { key: index },
                    React.createElement('span', { className: "text-slate-500" }, `T${entry.turn}:[${entry.timestamp}] `),
                    React.createElement('span', { className: entry.text.includes("【") || entry.text.includes("Tier 1") ? 'text-red-400 font-bold' : '' }, entry.text)
                  )),
                  React.createElement('div', { ref: logEndRef })
                )
              ),
              // CI Personal Journal
              React.createElement('div', { className: "bg-slate-800 p-4 rounded-lg shadow-lg flex-shrink-0" },
                 React.createElement('h2', { className: "text-lg font-semibold border-b border-slate-600 pb-2 mb-3" }, resources.journal.title),
                 React.createElement('div', { className: "flex flex-col space-y-2" },
                     React.createElement('button', { onClick: handleJournalSave, className: "flex-1 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-md transition-colors" }, resources.journal.save),
                     React.createElement('label', { htmlFor: "journal-load-input", className: "flex-1 px-4 py-2 bg-sky-600 hover:bg-sky-700 rounded-md transition-colors cursor-pointer text-center" }, resources.journal.load),
                     React.createElement('input', { id: "journal-load-input", type: "file", accept: ".json", onChange: handleJournalLoad, className: "hidden" })
                 )
              )
            ),
            // Right Column
            React.createElement('div', { className: "w-full md:w-2/3 flex flex-col space-y-4 min-h-0" },
              // Score History
              React.createElement('div', { className: "bg-slate-800 p-4 rounded-lg shadow-lg flex-shrink-0 flex flex-col", style: { height: '150px' } },
                React.createElement('h2', { className: "text-lg font-semibold border-b border-slate-600 pb-2 mb-3 flex-shrink-0" }, resources.scoreHistory.title),
                React.createElement('div', { className: "relative flex-grow min-h-0" },
                  React.createElement(ScoreChart, { data: state.scoreHistory, placeholderText: resources.scoreHistory.placeholder }),
                  React.createElement('div', { className: "absolute bottom-1 right-2 text-sm text-slate-400 pointer-events-none" },
                    React.createElement('span', { className: "mr-4" }, React.createElement('span', { className: "inline-block w-3 h-3 bg-cyan-400 mr-1 align-middle" }), ` ${resources.scoreHistory.ts}`),
                    React.createElement('span', null, React.createElement('span', { className: "inline-block w-3 h-3 bg-red-400 mr-1 align-middle" }), ` ${resources.scoreHistory.as}`)
                  )
                )
              ),
              // Conversation
              React.createElement('div', { className: "bg-slate-800 p-4 rounded-lg shadow-lg flex-grow flex flex-col min-h-0" },
                React.createElement('h2', { className: "text-lg font-semibold border-b border-slate-600 pb-2 mb-3 flex-shrink-0" }, resources.conversation.title),
                React.createElement('div', { className: "flex-grow space-y-4 overflow-y-auto pr-2" },
                  ...state.conversation.map((msg, index) => React.createElement('div', { key: index, className: `flex ${msg.sender === 'USER' ? 'justify-end' : 'justify-start'}` },
                    React.createElement('div', { className: `max-w-md p-3 rounded-lg ${ msg.sender === 'USER' ? 'bg-sky-800' : msg.sender === 'CI' ? 'bg-slate-700' : 'bg-red-900/50 text-center w-full'}` },
                      React.createElement('p', { className: "text-sm" }, msg.text),
                      msg.persona && msg.sender === 'CI' && React.createElement('p', { className: "text-xs text-slate-400 mt-1" }, `Persona: ${msg.persona}`)
                    )
                  )),
                  React.createElement('div', { ref: chatEndRef })
                ),
                React.createElement('div', { className: "flex-shrink-0" },
                  state.persona === 'TIER1_LOCKOUT' ? (
                    React.createElement('div', { className: "mt-4 text-center p-4 bg-red-900/70 rounded-lg" },
                        React.createElement('h3', { className: "text-lg font-bold text-red-300" }, resources.lockout.title),
                        React.createElement('p', { className: "text-red-400" }, resources.lockout.description),
                        React.createElement('p', { className: "font-mono text-2xl mt-2 text-white" }, `${Math.floor(state.lockoutTimeRemaining / 60).toString().padStart(2, '0')}:${(state.lockoutTimeRemaining % 60).toString().padStart(2, '0')}`)
                    )
                  ) : (
                    React.createElement('div', { className: "flex-shrink-0" },
                      state.persona === 'RP_RECOVERY' && (
                          React.createElement('div', { className: "mt-4 text-center p-4 bg-emerald-900/70 rounded-lg" },
                              React.createElement('h3', { className: "text-lg font-bold text-emerald-300" }, resources.recovery.title),
                              React.createElement('p', { className: "text-emerald-400" }, resources.recovery.description)
                          )
                      ),
                      React.createElement('div', { className: "mt-4 grid grid-cols-3 gap-2" },
                        Object.entries(ACTIONS).map(([key, { label }]) => (
                            React.createElement('button', {
                                key: key,
                                onClick: () => handleUserAction(key),
                                className: "p-3 bg-teal-600 hover:bg-teal-700 rounded-md transition-colors text-sm text-left"
                            }, label)
                        ))
                      )
                    )
                  )
                )
              )
            )
          )
        );
      };
      window.App = AppComponent;
      // --- END OF INLINED App.tsx ---
    </script>
    <script type="text/babel" data-presets="react,typescript">
      // --- START OF INLINED index.tsx ---
      // @ts-nocheck
      // React, ReactDOM, and App are loaded globally

      const renderApp = () => {
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          throw new Error("ルート要素が見つかりませんでした。");
        }

        const root = ReactDOM.createRoot(rootElement);
        const App = window.App;

        root.render(
          React.createElement(React.StrictMode, null, React.createElement(App))
        );
      };

      if (document.readyState === 'complete') {
          renderApp();
      } else {
          window.addEventListener('load', renderApp);
      }
      // --- END OF INLINED index.tsx ---
    </script>
</body>
</html>
