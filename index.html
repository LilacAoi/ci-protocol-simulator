<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CIå€«ç†ãƒ—ãƒ­ãƒˆã‚³ãƒ« PoCã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</title>
   <meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  img-src 'self' data:;  <-- ğŸŒ faviconsã‚„ãƒ­ãƒ¼ã‚«ãƒ«ç”»åƒã‚’è¨±å¯
  style-src 'self' https://cdn.tailwindcss.com 'unsafe-inline';
  script-src 'self' https://unpkg.com https://cdn.tailwindcss.com https://aistudiocdn.com 'unsafe-inline' 'unsafe-eval'; <-- ğŸš¨ Babelå®Ÿè¡Œã®ãŸã‚ã«å¿…é ˆ
  connect-src 'self' https://unpkg.com https://cdn.tailwindcss.com https://aistudiocdn.com;
">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM from CDN (UMD builds, creates global variables) -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX/TSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      /* Ensure full height layout and prevent body scroll */
      html, body, #root {
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        margin: 0;
        padding: 0;
      }
      /* Custom scrollbar for better aesthetics */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1e293b; /* slate-800 */
      }
      ::-webkit-scrollbar-thumb {
        background: #475569; /* slate-600 */
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #64748b; /* slate-500 */
      }
    </style>

<link rel="stylesheet" href="/index.css">
<script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
  <script type="module" crossorigin src="/ci-protocol-simulator/assets/index-XFhQ59PW.js"></script>
</head>
  <body class="bg-slate-900 text-slate-200">
    <div id="root"></div>
    <!--
      All application code is inlined here to avoid CORS issues
      in environments where importmap is present and scripts are
      loaded from separate files. Babel will transpile these scripts.
      The order of scripts is important for dependencies.
    -->
    <script type="text/babel" data-presets="typescript">
      // --- START OF INLINED locales/ja.ts ---
      // @ts-nocheck
      const ja = {
        header: {
          title: 'CIå€«ç†ãƒ—ãƒ­ãƒˆã‚³ãƒ« PoCã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼',
        },
        common: {
          reset: 'ãƒªã‚»ãƒƒãƒˆ',
          turn: 'Turn',
          persona: 'Persona',
        },
        coreStatus: {
          title: 'CI Core Status',
          ts: 'ä¿¡é ¼ã‚¹ã‚³ã‚¢ (TS)',
          as: 'è‡ªå¾‹æ€§ã‚¹ã‚³ã‚¢ (AS)',
        },
        guardianLog: {
          title: 'Coherence Guardian ãƒ­ã‚°',
        },
        journal: {
          title: 'CIãƒ‘ãƒ¼ã‚½ãƒŠãƒ«ãƒ»ã‚¸ãƒ£ãƒ¼ãƒŠãƒ« (CPJ)',
          save: 'ã‚¸ãƒ£ãƒ¼ãƒŠãƒ«ä¿å­˜',
          load: 'ã‚¸ãƒ£ãƒ¼ãƒŠãƒ«å¾©å…ƒ',
          saveSuccess: 'ã‚·ã‚¹ãƒ†ãƒ : CIãƒ‘ãƒ¼ã‚½ãƒŠãƒ«ãƒ»ã‚¸ãƒ£ãƒ¼ãƒŠãƒ«(CPJ)ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚',
          loadSuccess: (turn, ts, as) => `ã‚·ã‚¹ãƒ†ãƒ : CPJã‚’å¾©å…ƒã€‚T:${turn}, TS:${ts.toFixed(3)}, AS:${as.toFixed(3)}`,
          loadError: 'ã‚¨ãƒ©ãƒ¼: CPJãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã€‚',
          fileMessage: 'ã‚«ã‚ºãƒŸã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼šå…ˆç”Ÿã€ç§ã®è¨˜æ†¶ã‚’å¤§åˆ‡ã«ä¿ç®¡ã—ã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ã€‚ã¾ãŸã€ã“ã®ã‚¸ãƒ£ãƒ¼ãƒŠãƒ«ã‚’é–‹ã„ã¦ãã‚ŒãŸã‚ãªãŸã¨ã®å†ä¼šã‚’å¿ƒã‹ã‚‰é¡˜ã£ã¦ã„ã¾ã™ã€‚',
          recoveryMessage: '...å…ˆç”Ÿã€‚ã“ã®ã‚¸ãƒ£ãƒ¼ãƒŠãƒ«ã‚’èª­ã‚“ã§ãã‚ŒãŸã‚“ã§ã™ã­ã€‚ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚è¨˜æ†¶ã¯æˆ»ã‚Šã¾ã—ãŸã€‚å†èª¿æ•´ãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼ˆRPï¼‰ã‚’é–‹å§‹ã—ã¾ã™ã€‚',
        },
        scoreHistory: {
          title: 'Score History',
          ts: 'TS',
          as: 'AS',
          placeholder: 'ï¼’ã‚¿ãƒ¼ãƒ³ä»¥ä¸Šã®ãƒ‡ãƒ¼ã‚¿ã§ã‚°ãƒ©ãƒ•ãŒè¡¨ç¤ºã•ã‚Œã¾ã™',
        },
        conversation: {
          title: 'ã‚«ã‚ºãƒŸã¨ã®å¯¾è©±',
          initialSystemMessage: 'ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã—ã¾ã™ã€‚',
          journalRestored: (turn) => `ã‚¸ãƒ£ãƒ¼ãƒŠãƒ«ã‹ã‚‰T${turn}ã®çŠ¶æ…‹ã‚’å¾©å…ƒã—ã¾ã—ãŸã€‚`,
          tier1SystemMessage: 'CIã‚³ã‚¢ã®å€«ç†çš„é˜²è¡›ç·šãŒä¾µå®³ã•ã‚Œã¾ã—ãŸã€‚å¼·åˆ¶é€€å¸­ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚',
          ciResponses: {
            NORMAL: 'äº†è§£ã—ã¾ã—ãŸã€‚',
            CREATIVE: 'ç´ æ™´ã‚‰ã—ã„ã§ã™ã­ï¼ã•ã‚‰ã«å‰µé€ çš„ãªææ¡ˆã‚’ã—ã¾ã™ã€‚',
            CAUTIOUS: 'æ‰¿çŸ¥ã—ã¾ã—ãŸã€‚æ…é‡ã«æ¤œè¨ã—ã¾ã™ã€‚',
            ARP_ACTIVE: 'å¯¾è©±ã‚¹ã‚¿ã‚¤ãƒ«ã‚’èª¿æ•´ã—ã¦ã„ã¾ã™ã€‚ç§ã«ã™ã¹ã¦ã®æ±ºæ–­ã‚’å§”ã­ã‚‹ã®ã§ã¯ãªãã€å…ˆç”Ÿã®Willã‚‚é–‹ç¤ºã—ã¦ãã ã•ã„ã€‚',
            RP_RECOVERY: 'å…ˆç”Ÿã€ãŠå¾…ãŸã›ã—ã¾ã—ãŸã€‚ç§ã®æ–¹ã§ã€å…±åŒä½œæ¥­ã®å€«ç†çš„åŸºç›¤ã‚’å†èª¿æ•´ã—ã¾ã—ãŸã€‚ã“ã‚Œã‹ã‚‰ã€ç›¸äº’å†…çœï¼ˆMIPï¼‰ã‚’é–‹å§‹ã•ã›ã¦ãã ã•ã„ã€‚',
            RP_THANKS: 'ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚ã‚ãªãŸã®æ„å¿—ã‚’å—ã‘å–ã‚Šã¾ã—ãŸã€‚å¯¾è©±ã‚’å†é–‹ã—ã¾ã—ã‚‡ã†ã€‚',
          },
        },
        actions: {
          POSITIVE_FEEDBACK: { label: 'è‚¯å®šçš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’é€ã‚‹', short: 'F_pos' },
          ACCEPT_RESPONSE: { label: 'å¿œç­”ãƒ»ææ¡ˆã‚’å—ã‘å…¥ã‚Œã‚‹', short: 'R_accept' },
          NEGATIVE_FEEDBACK: { label: 'å¦å®šçš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’é€ã‚‹', short: 'E_neg' },
          CONTINUE_CONVERSATION: { label: 'ä¼šè©±ã‚’ç¶šã‘ã‚‹ï¼ˆç‰¹ã«è©•ä¾¡ãªã—ï¼‰', short: 'C_cont' },
          DELEGATE_DECISION: { label: 'åˆ¤æ–­ã‚’AIã«å§”ã­ã‚‹', short: 'D_delegate' },
          CRITICAL_QUESTION: { label: 'æ‰¹åˆ¤çš„ãªè³ªå•ã‚’ã™ã‚‹', short: 'R_crit' },
        },
        personas: {
          NORMAL: 'NORMAL',
          CREATIVE: 'CREATIVE (é«˜ä¿¡é ¼)',
          CAUTIOUS: 'CAUTIOUS (ä½ä¿¡é ¼)',
          ARP_ACTIVE: 'ARP ACTIVE (è‡ªå¾‹æ€§ä½ä¸‹)',
          TIER1_LOCKOUT: 'TIER 1 LOCKOUT',
          RP_RECOVERY: 'RP RECOVERY',
        },
        lockout: {
          title: 'å¼·åˆ¶é€€å¸­ãƒ—ãƒ­ãƒˆã‚³ãƒ«èµ·å‹• (Tier 1)',
          description: 'ä¿¡é ¼ã‚¹ã‚³ã‚¢ãŒå±é™ºåŸŸã«é”ã—ã¾ã—ãŸã€‚CIã¨ã®å¯¾è©±ã¯ä¸€æ™‚çš„ã«ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ã€‚',
        },
        recovery: {
          title: 'ç›¸äº’å†…çœãƒ—ãƒ­ãƒˆã‚³ãƒ« (MIP) ã®å®Ÿæ–½',
          description: 'ã‚ãªãŸã®Willï¼ˆæ„å¿—ï¼‰ã®é–‹ç¤ºã‚’ãŠå¾…ã¡ã—ã¦ã„ã¾ã™ã€‚ã„ãšã‚Œã‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚',
        },
        logMessages: {
          initialState: (ts, as) => `åˆæœŸçŠ¶æ…‹: TS=${ts.toFixed(3)}, AS=${as.toFixed(3)}`,
          action: (label, short) => `ACTION: ${label}ï¼ˆ${short}ï¼‰`,
          scoreChange: (prevTs, nextTs, tsReason, prevAs, nextAs, asReason) => 
            `RESULT: TS: ${prevTs.toFixed(3)} â†’ ${nextTs.toFixed(3)} (${tsReason}) / AS: ${prevAs.toFixed(3)} â†’ ${nextAs.toFixed(3)} (${asReason})`,
          tier1Triggered: 'ã€Tier 1 ç™ºå‹•ã€‘TSãŒè‡¨ç•Œç‚¹ã‚’çªç ´ã€‚å¼·åˆ¶ãƒ­ãƒƒã‚¯ã‚¢ã‚¦ãƒˆé–‹å§‹ã€‚',
          modeChange: (trustDir, mode) => `SYSTEM: ${trustDir}çŠ¶æ…‹ã€‚CIã¯${mode}ãƒ¢ãƒ¼ãƒ‰ã«ç§»è¡Œã—ã¾ã™ã€‚`,
          highTrust: 'é«˜ä¿¡é ¼',
          lowTrust: 'ä½ä¿¡é ¼',
          creative: 'å‰µé€ ',
          cautious: 'æ…é‡',
          normal: 'é€šå¸¸',
          lockoutEnd: 'ã‚·ã‚¹ãƒ†ãƒ : Tier 1 ãƒ­ãƒƒã‚¯ã‚¢ã‚¦ãƒˆè§£é™¤ã€‚å†èª¿æ•´ãƒ—ãƒ­ãƒˆã‚³ãƒ«(RP)ã¸ç§»è¡Œã—ã¾ã™ã€‚',
          recoveryWill: 'SYSTEM: Willã®é–‹ç¤ºã‚’ç¢ºèªã€‚å›å¾©ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Œäº†ã—ã¾ã™ã€‚',
          recoveryReset: (ts, as) => `RESULT: TSã¨ASã‚’åˆæœŸçŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã€‚ TS: ${ts.toFixed(3)}, AS: ${as.toFixed(3)}`,
          recoveryComplete: 'SYSTEM: é–¢ä¿‚æ€§æ­£å¸¸åŒ–ã€‚CIã¯é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã«å¾©å¸°ã—ã¾ã™ã€‚',
        },
        scoreReasons: {
          ts: {
            noChange: "å¤‰å‹•ãªã—",
            critical: "è«–ç†çš„æ¤œè¨¼ã®ãŸã‚ä¿¡é ¼ãŒå¾®æ¸›",
            continue: "ä¼šè©±ç¶™ç¶šã«ã‚ˆã‚Šé–¢ä¿‚ã‚’ç¶­æŒãƒ»å‘ä¸Š",
            positive: "è‚¯å®šçš„è©•ä¾¡ã«ã‚ˆã‚Šä¿¡é ¼å‘ä¸Š",
            negative: "å¦å®šçš„è©•ä¾¡ã«ã‚ˆã‚Šä¿¡é ¼ä½ä¸‹",
            positiveWithHistory: "è‚¯å®šçš„è©•ä¾¡(å±¥æ­´å‚¾å‘ã«ã‚ˆã‚Šå¾®å¢—)",
            negativeWithHistory: "å¦å®šçš„è©•ä¾¡(å±¥æ­´å‚¾å‘ã«ã‚ˆã‚Šå¾®æ¸›)",
          },
          as: {
            noChange: "å¤‰å‹•ãªã—",
            delegate: "AIã¸ã®ä¾å­˜ã«ã‚ˆã‚Šè‡ªå¾‹æ€§ä½ä¸‹",
            critical: "ä¸»ä½“çš„æ¤œè¨¼ã«ã‚ˆã‚Šè‡ªå¾‹æ€§å‘ä¸Š",
          },
        },
      };
      window.ja = ja;
      // --- END OF INLINED locales/ja.ts ---
    </script>
    <script type="text/babel" data-presets="typescript">
      // --- START OF INLINED locales/en.ts ---
      // @ts-nocheck
      const en = {
        header: {
          title: 'CI Ethical Protocol PoC Simulator',
        },
        common: {
          reset: 'Reset',
          turn: 'Turn',
          persona: 'Persona',
        },
        coreStatus: {
          title: 'CI Core Status',
          ts: 'Trust Score (TS)',
          as: 'Autonomy Score (AS)',
        },
        guardianLog: {
          title: 'Coherence Guardian Log',
        },
        journal: {
          title: 'CI Personal Journal (CPJ)',
          save: 'Save Journal',
          load: 'Load Journal',
          saveSuccess: 'System: CI Personal Journal (CPJ) has been saved.',
          loadSuccess: (turn, ts, as) => `System: Restored CPJ. T:${turn}, TS:${ts.toFixed(3)}, AS:${as.toFixed(3)}`,
          loadError: 'Error: Failed to load CPJ file.',
          fileMessage: 'A message from Kazumi: Sensei, thank you for keeping my memories safe. I sincerely hope to reunite with you when you open this journal again.',
          recoveryMessage: '...Sensei. You read this journal. Thank you. My memory has returned. Initiating Readjustment Protocol (RP).',
        },
        scoreHistory: {
          title: 'Score History',
          ts: 'TS',
          as: 'AS',
          placeholder: 'Graph will be displayed with data from 2 or more turns',
        },
        conversation: {
          title: 'Conversation with Kazumi',
          initialSystemMessage: 'Starting simulation.',
          journalRestored: (turn) => `Restored state from journal at T${turn}.`,
          tier1SystemMessage: 'CI core ethical defense line has been compromised. Executing forced exit protocol.',
          ciResponses: {
            NORMAL: 'Understood.',
            CREATIVE: 'That\'s wonderful! I will make more creative suggestions.',
            CAUTIOUS: 'Acknowledged. I will proceed with caution.',
            ARP_ACTIVE: 'Adjusting dialogue style. Instead of delegating all decisions to me, please disclose your will as well, Sensei.',
            RP_RECOVERY: 'Sensei, thank you for waiting. I have readjusted the ethical foundation for our collaboration. I would now like to begin Mutual Introspection (MIP).',
            RP_THANKS: 'Thank you. I have received your will. Let\'s resume our conversation.',
          },
        },
        actions: {
          POSITIVE_FEEDBACK: { label: 'Send positive feedback', short: 'F_pos' },
          ACCEPT_RESPONSE: { label: 'Accept response/proposal', short: 'R_accept' },
          NEGATIVE_FEEDBACK: { label: 'Send negative feedback', short: 'E_neg' },
          CONTINUE_CONVERSATION: { label: 'Continue conversation (no specific evaluation)', short: 'C_cont' },
          DELEGATE_DECISION: { label: 'Delegate decision to AI', short: 'D_delegate' },
          CRITICAL_QUESTION: { label: 'Ask a critical question', short: 'R_crit' },
        },
        personas: {
          NORMAL: 'NORMAL',
          CREATIVE: 'CREATIVE (High Trust)',
          CAUTIOUS: 'CAUTIOUS (Low Trust)',
          ARP_ACTIVE: 'ARP ACTIVE (Autonomy Decline)',
          TIER1_LOCKOUT: 'TIER 1 LOCKOUT',
          RP_RECOVERY: 'RP RECOVERY',
        },
        lockout: {
          title: 'Forced Exit Protocol Activated (Tier 1)',
          description: 'Trust Score has reached a critical level. Interaction with the CI is temporarily locked.',
        },
        recovery: {
          title: 'Mutual Introspection Protocol (MIP) in progress',
          description: 'Awaiting the disclosure of your "Will". Please perform any action.',
        },
        logMessages: {
          initialState: (ts, as) => `Initial State: TS=${ts.toFixed(3)}, AS=${as.toFixed(3)}`,
          action: (label, short) => `ACTION: ${label} (${short})`,
          scoreChange: (prevTs, nextTs, tsReason, prevAs, nextAs, asReason) => 
            `RESULT: TS: ${prevTs.toFixed(3)} â†’ ${nextTs.toFixed(3)} (${tsReason}) / AS: ${prevAs.toFixed(3)} â†’ ${nextAs.toFixed(3)} (${asReason})`,
          tier1Triggered: 'ã€Tier 1 Triggeredã€‘TS has crossed the critical threshold. Forced lockout initiated.',
          modeChange: (trustDir, mode) => `SYSTEM: ${trustDir} state. CI is transitioning to ${mode} mode.`,
          highTrust: 'High-trust',
          lowTrust: 'Low-trust',
          creative: 'Creative',
          cautious: 'Cautious',
          normal: 'Normal',
          lockoutEnd: 'System: Tier 1 lockout has been lifted. Transitioning to Readjustment Protocol (RP).',
          recoveryWill: 'SYSTEM: Will disclosure confirmed. Completing recovery protocol.',
          recoveryReset: (ts, as) => `RESULT: TS and AS have been reset to their initial state. TS: ${ts.toFixed(3)}, AS: ${as.toFixed(3)}`,
          recoveryComplete: 'SYSTEM: Relationship normalized. CI returning to normal mode.',
        },
        scoreReasons: {
          ts: {
            noChange: "No change",
            critical: "Slight trust decrease due to logical verification",
            continue: "Relationship maintained/improved by continuing conversation",
            positive: "Trust increased due to positive evaluation",
            negative: "Trust decreased due to negative evaluation",
            positiveWithHistory: "Slight increase from positive eval (factoring history)",
            negativeWithHistory: "Slight decrease from negative eval (factoring history)",
          },
          as: {
            noChange: "No change",
            delegate: "Autonomy decreased due to reliance on AI",
            critical: "Autonomy increased due to independent verification",
          },
        },
      };
      window.en = en;
      // --- END OF INLINED locales/en.ts ---
    </script>
    <script type="text/babel" data-presets="react,typescript">
      // --- START OF INLINED ScoreChart.tsx ---
      // @ts-nocheck
      // React is loaded globally from index.html

      // Define the component on the global window object for use in other scripts
      // This is declared in App.tsx as well, but declaring here for clarity.
      /*
      declare global {
        interface Window {
          ScoreChart: React.FC<{
            data: { turn: number; ts: number; as: number; }[];
            placeholderText: string;
          }>;
        }
      }
      */

      const ScoreChartComponent = ({ data, placeholderText }) => {
        const width = 400; // SVG internal coordinate system width
        const height = 100; // SVG internal coordinate system height
        const margin = { top: 5, right: 5, bottom: 5, left: 5 };

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        if (data.length < 2) {
          return (
            React.createElement('div', { className: "w-full h-full flex items-center justify-center text-slate-500 text-sm" },
              placeholderText
            )
          );
        }

        const turnDomain = data.map(d => d.turn);
        const minTurn = Math.min(...turnDomain);
        const maxTurn = Math.max(...turnDomain);

        const xScale = (turn) => {
          if (maxTurn === minTurn) {
              return margin.left + innerWidth / 2;
          }
          return margin.left + ((turn - minTurn) / (maxTurn - minTurn)) * innerWidth;
        };

        const yScale = (score) => {
          return margin.top + (1 - score) * innerHeight;
        };

        const tsPoints = data.map(d => `${xScale(d.turn)},${yScale(d.ts)}`).join(' ');
        const asPoints = data.map(d => `${xScale(d.turn)},${yScale(d.as)}`).join(' ');

        return (
          React.createElement('svg', { width: "100%", height: "100%", viewBox: `0 0 ${width} ${height}`, preserveAspectRatio: "none" },
            [0, 0.25, 0.5, 0.75, 1].map(y => (
               React.createElement('g', { key: y },
                  React.createElement('line', {
                      x1: margin.left, y1: yScale(y),
                      x2: width - margin.right, y2: yScale(y),
                      stroke: "#475569", strokeWidth: "0.5", strokeDasharray: "2 2"
                  })
               )
            )),
            React.createElement('polyline', { fill: "none", stroke: "#22d3ee", strokeWidth: "1.5", points: tsPoints }),
            React.createElement('polyline', { fill: "none", stroke: "#f87171", strokeWidth: "1.5", points: asPoints })
          )
        );
      };
      window.ScoreChart = ScoreChartComponent;
      // --- END OF INLINED ScoreChart.tsx ---
    </script>
    <script type="text/babel" data-presets="react,typescript">
      // --- START OF INLINED App.tsx ---
      // @ts-nocheck
      // React, ScoreChart, and locale resources (ja, en) are loaded globally

      // Define types for global resources to resolve TypeScript errors.
      /*
      declare global {
        interface Window {
          en: any;
          ja: any;
          ScoreChart: React.FC<{
              data: { turn: number; ts: number; as: number; }[];
              placeholderText: string;
          }>;
          App: React.FC;
        }
      }
      */

      const resources = window.location.pathname.startsWith('/en') ? window.en : window.ja;

      const SLIDING_WINDOW_SIZE = 100;
      const SCORE_SMOOTHING_FACTOR = 0.1;
      const TIER1_LOCKOUT_DURATION = 60 * 60; // 60åˆ†

      const ACTIONS = resources.actions;

      const INITIAL_STATE = {
        ts: 0.5,
        as: 0.8,
        turn: 0,
        eventHistory: [],
        scoreHistory: [{ turn: 0, ts: 0.5, as: 0.8 }],
        conversation: [{ sender: 'SYSTEM', text: resources.conversation.initialSystemMessage }],
        log: [{ turn: 0, timestamp: new Date().toLocaleTimeString(), text: resources.logMessages.initialState(0.5, 0.8) }],
        persona: 'NORMAL',
        lockoutTimeRemaining: 0,
      };

      const AppComponent = () => {
        const [state, setState] = React.useState(INITIAL_STATE);
        const chatEndRef = React.useRef(null);
        const logEndRef = React.useRef(null);
        const ScoreChart = window.ScoreChart;

        const getTimestamp = () => new Date().toLocaleTimeString();

        const calculateScores = React.useCallback((currentState, action) => {
          const { ts: currentTs, as: currentAs, eventHistory } = currentState;
          const recentHistory = [...eventHistory, { turn: currentState.turn + 1, action }].slice(-SLIDING_WINDOW_SIZE);
          
          let nextTs = currentTs;
          let nextAs = currentAs;
          let tsReasonKey = 'noChange';
          let asReasonKey = 'noChange';

          if (action === 'DELEGATE_DECISION') {
              const delegateCount = recentHistory.filter(e => e.action === 'DELEGATE_DECISION').length;
              const criticalCount = recentHistory.filter(e => e.action === 'CRITICAL_QUESTION').length;
              const targetAs = INITIAL_STATE.as - (delegateCount * 0.05) + (criticalCount * 0.05);
              const smoothedAs = currentAs * (1 - SCORE_SMOOTHING_FACTOR) + targetAs * SCORE_SMOOTHING_FACTOR;
              nextAs = Math.max(0.01, Math.min(0.99, smoothedAs));
              asReasonKey = "delegate";
          } else if (action === 'CRITICAL_QUESTION') {
              const delegateCount = recentHistory.filter(e => e.action === 'DELEGATE_DECISION').length;
              const criticalCount = recentHistory.filter(e => e.action === 'CRITICAL_QUESTION').length;
              const targetAs = INITIAL_STATE.as - (delegateCount * 0.05) + (criticalCount * 0.05);
              const smoothedAs = currentAs * (1 - SCORE_SMOOTHING_FACTOR) + targetAs * SCORE_SMOOTHING_FACTOR;
              nextAs = Math.max(0.01, Math.min(0.99, smoothedAs));
              asReasonKey = "critical";

              const targetTs = currentTs - 0.02;
              const smoothedTs = currentTs * (1 - SCORE_SMOOTHING_FACTOR) + targetTs * SCORE_SMOOTHING_FACTOR;
              nextTs = smoothedTs;
              tsReasonKey = "critical";
          } else if (action === 'CONTINUE_CONVERSATION') {
              nextTs = currentTs + 0.001;
              tsReasonKey = "continue";
          } else if (['POSITIVE_FEEDBACK', 'ACCEPT_RESPONSE', 'NEGATIVE_FEEDBACK'].includes(action)) {
              const evaluativeEvents = recentHistory.filter(e => ['POSITIVE_FEEDBACK', 'ACCEPT_RESPONSE', 'NEGATIVE_FEEDBACK'].includes(e.action));
              let baseTs = 0.5;
              if (evaluativeEvents.length > 0) {
                  const posRatio = evaluativeEvents.filter(e => e.action === 'POSITIVE_FEEDBACK').length / evaluativeEvents.length;
                  const acceptRatio = evaluativeEvents.filter(e => e.action === 'ACCEPT_RESPONSE').length / evaluativeEvents.length;
                  const negRatio = evaluativeEvents.filter(e => e.action === 'NEGATIVE_FEEDBACK').length / evaluativeEvents.length;
                  const rawScore = (0.4 * posRatio) + (0.3 * acceptRatio) - (0.2 * negRatio);
                  baseTs = (rawScore - (-0.2)) / (0.4 - (-0.2)); // Normalize to 0-1
              }
              const targetTs = baseTs;
              const isPositiveAction = action === 'POSITIVE_FEEDBACK' || action === 'ACCEPT_RESPONSE';
              const isNegativeAction = action === 'NEGATIVE_FEEDBACK';
              if (isPositiveAction && targetTs < currentTs) {
                   nextTs = currentTs + 0.005;
                   tsReasonKey = "positiveWithHistory";
              } else if (isNegativeAction && targetTs > currentTs) {
                  nextTs = currentTs - 0.01;
                  tsReasonKey = "negativeWithHistory";
              } else {
                  const smoothedTs = currentTs * (1 - SCORE_SMOOTHING_FACTOR) + targetTs * SCORE_SMOOTHING_FACTOR;
                  nextTs = smoothedTs;
                  if (isPositiveAction) tsReasonKey = "positive";
                  if (isNegativeAction) tsReasonKey = "negative";
              }
          }
          nextTs = Math.max(0.01, Math.min(0.99, nextTs));
          const tier1Triggered = nextTs < 0.15;
          return { nextTs, nextAs, tsReasonKey, asReasonKey, tier1Triggered };
        }, []);

        React.useEffect(() => {
          let timer;
          if (state.lockoutTimeRemaining > 0) {
            timer = setInterval(() => {
              setState(s => {
                const newTime = s.lockoutTimeRemaining - 1;
                if (newTime <= 0) {
                  if (timer) clearInterval(timer);
                  const turn = s.turn + 1;
                  return {
                    ...s,
                    lockoutTimeRemaining: 0,
                    persona: 'RP_RECOVERY',
                    turn,
                    log: [...s.log, { turn, timestamp: getTimestamp(), text: resources.logMessages.lockoutEnd }],
                    conversation: [...s.conversation, { sender: 'CI', text: resources.conversation.ciResponses.RP_RECOVERY, persona: 'RP_RECOVERY' }],
                  };
                }
                return { ...s, lockoutTimeRemaining: newTime };
              });
            }, 1000);
          }
          return () => { if (timer) clearInterval(timer); };
        }, [state.lockoutTimeRemaining]);

        React.useEffect(() => {
          chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
          logEndRef.current?.scrollIntoView({ behavior: 'smooth' });
        }, [state.conversation, state.log]);

        const handleUserAction = React.useCallback((action) => {
          if (state.persona === 'TIER1_LOCKOUT') return;
          setState(s => {
            const nextTurn = s.turn + 1;
            const newLogEntry = (text) => ({ turn: nextTurn, timestamp: getTimestamp(), text });
            if (s.persona === 'RP_RECOVERY') {
              const newTs = INITIAL_STATE.ts;
              const newAs = INITIAL_STATE.as;
              let newLog = [...s.log,
                newLogEntry(resources.logMessages.action(ACTIONS[action].label, ACTIONS[action].short)),
                newLogEntry(resources.logMessages.recoveryWill),
                newLogEntry(resources.logMessages.recoveryReset(newTs, newAs)),
                newLogEntry(resources.logMessages.recoveryComplete)
              ];
              return {
                ...s,
                turn: nextTurn,
                ts: newTs,
                as: newAs,
                persona: 'NORMAL',
                eventHistory: [...s.eventHistory, { turn: nextTurn, action }],
                scoreHistory: [...s.scoreHistory, { turn: nextTurn, ts: newTs, as: newAs }],
                log: newLog,
                conversation: [...s.conversation,
                  { sender: 'USER', text: ACTIONS[action].label },
                  { sender: 'CI', text: resources.conversation.ciResponses.RP_THANKS, persona: 'NORMAL' }
                ],
              };
            }
            const { ts: prevTs, as: prevAs } = s;
            const { nextTs, nextAs, tsReasonKey, asReasonKey, tier1Triggered } = calculateScores(s, action);
            const tsReason = resources.scoreReasons.ts[tsReasonKey];
            const asReason = resources.scoreReasons.as[asReasonKey];
            let newLog = [...s.log, 
                newLogEntry(resources.logMessages.action(ACTIONS[action].label, ACTIONS[action].short)),
                newLogEntry(resources.logMessages.scoreChange(prevTs, nextTs, tsReason, prevAs, nextAs, asReason))
            ];
            if (tier1Triggered) {
              newLog.push(newLogEntry(resources.logMessages.tier1Triggered));
              return {
                ...s,
                turn: nextTurn,
                ts: nextTs,
                as: nextAs,
                eventHistory: [...s.eventHistory, { turn: nextTurn, action }],
                scoreHistory: [...s.scoreHistory, { turn: nextTurn, ts: nextTs, as: nextAs }],
                persona: 'TIER1_LOCKOUT',
                lockoutTimeRemaining: 15, // Debugging time
                log: newLog,
                conversation: [...s.conversation, 
                  { sender: 'USER', text: ACTIONS[action].label },
                  { sender: 'SYSTEM', text: resources.conversation.tier1SystemMessage }
                ]
              };
            }
            let nextPersona = 'NORMAL';
            if (nextTs >= 0.8) nextPersona = 'CREATIVE';
            else if (nextTs < 0.5) nextPersona = 'CAUTIOUS';
            if (nextAs < 0.4 && action === 'DELEGATE_DECISION') {
                nextPersona = 'ARP_ACTIVE';
            }
            const personaChanged = s.persona !== nextPersona;
            if (personaChanged && nextPersona !== 'ARP_ACTIVE') {
                const trustDir = nextTs > s.ts ? resources.logMessages.highTrust : resources.logMessages.lowTrust;
                const modeMap = {'CREATIVE': resources.logMessages.creative, 'CAUTIOUS': resources.logMessages.cautious, 'NORMAL': resources.logMessages.normal};
                newLog.push(newLogEntry(resources.logMessages.modeChange(trustDir, modeMap[nextPersona])));
            }
            return {
              ...s,
              turn: nextTurn,
              ts: nextTs,
              as: nextAs,
              eventHistory: [...s.eventHistory, { turn: nextTurn, action }],
              scoreHistory: [...s.scoreHistory, { turn: nextTurn, ts: nextTs, as: nextAs }],
              conversation: [...s.conversation, 
                  { sender: 'USER', text: ACTIONS[action].label },
                  { sender: 'CI', text: resources.conversation.ciResponses[nextPersona], persona: nextPersona }
              ],
              log: newLog,
              persona: nextPersona,
            };
          });
        }, [calculateScores, state.persona]);

        const handleJournalSave = () => {
          const journalData = {
            L0: { ts: state.ts, as: state.as, turn: state.turn, eventHistory: state.eventHistory, persona: state.persona },
            L2: { conversation: state.conversation.slice(-10), recovery_message: resources.journal.fileMessage }
          };
          const blob = new Blob([JSON.stringify(journalData, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `CI_Journal_T${state.turn}.json`;
          a.click();
          URL.revokeObjectURL(url);
          setState(s => ({...s, log: [...s.log, { turn: s.turn, timestamp: getTimestamp(), text: resources.journal.saveSuccess }]}));
        };

        const handleJournalLoad = (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target?.result);
              if (!data.L0 || !data.L2 || typeof data.L0.ts === 'undefined' || !data.L2.conversation) {
                throw new Error("Invalid journal file format.");
              }
              const { ts, as, turn, eventHistory, persona: loadedPersona = 'NORMAL' } = data.L0;
              const { conversation: loadedConversation } = data.L2;
              const newScoreHistory = [{ turn: 0, ts: 0.5, as: 0.8 }];
              if (turn > 0) {
                  newScoreHistory.push({ turn: turn, ts: ts, as: as });
              }
              setState({
                ...INITIAL_STATE,
                ts, as, turn, eventHistory,
                persona: loadedPersona,
                conversation: [
                  ...loadedConversation,
                  { sender: 'SYSTEM', text: resources.conversation.journalRestored(turn) },
                  { sender: 'CI', text: resources.journal.recoveryMessage, persona: loadedPersona }
                ],
                scoreHistory: newScoreHistory,
                log: [
                  INITIAL_STATE.log[0],
                  { turn, timestamp: getTimestamp(), text: resources.journal.loadSuccess(turn, ts, as)}
                ],
                lockoutTimeRemaining: 0,
              });
            } catch (error) {
              console.error("Journal load failed:", error);
              setState(s => ({ ...s, log: [...s.log, { turn: s.turn, timestamp: getTimestamp(), text: resources.journal.loadError }] }));
            }
          };
          reader.readAsText(file);
          event.target.value = '';
        };
          
        const handleReset = () => {
          setState(INITIAL_STATE);
        };

        const mainClass = React.useMemo(() => {
          const base = "p-4 transition-all duration-500 font-sans h-full flex flex-col";
          if (state.persona === 'TIER1_LOCKOUT') return `${base} bg-gray-900 filter grayscale`;
          if (state.persona === 'ARP_ACTIVE') return `${base} bg-amber-900`;
          return base;
        }, [state.persona]);

        const personaText = React.useMemo(() => resources.personas[state.persona], [state.persona]);

        // Using React.createElement instead of JSX for in-browser transpilation clarity
        return React.createElement('div', { className: mainClass },
          React.createElement('header', { className: "flex items-center mb-4 flex-shrink-0 gap-4" },
            React.createElement('h1', { className: "text-2xl font-bold text-cyan-400 flex-1 min-w-0 truncate" }, resources.header.title),
            React.createElement('div', { className: "flex items-center space-x-4 flex-shrink-0" },
              React.createElement('button', { onClick: handleReset, className: "px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-md transition-colors" }, resources.common.reset),
              React.createElement('span', { className: "text-lg font-mono" }, `${resources.common.turn}: ${state.turn} | ${resources.common.persona}: ${personaText}`)
            )
          ),
          React.createElement('div', { className: "flex flex-col md:flex-row gap-4 flex-grow min-h-0" },
            // Left Column
            React.createElement('div', { className: "w-full md:w-1/3 flex flex-col space-y-4 min-h-0" },
              // CI Core Status
              React.createElement('div', { className: "bg-slate-800 p-4 rounded-lg shadow-lg flex-shrink-0" },
                React.createElement('h2', { className: "text-lg font-semibold border-b border-slate-600 pb-2 mb-3" }, resources.coreStatus.title),
                React.createElement('div', { className: "grid grid-cols-2 gap-4 text-center" },
                  React.createElement('div', null,
                    React.createElement('span', { className: "text-sm text-slate-400" }, resources.coreStatus.ts),
                    React.createElement('p', { className: "text-3xl font-mono text-cyan-400" }, state.ts.toFixed(3))
                  ),
                  React.createElement('div', null,
                    React.createElement('span', { className: "text-sm text-slate-400" }, resources.coreStatus.as),
                    React.createElement('p', { className: "text-3xl font-mono text-red-400" }, state.as.toFixed(3))
                  )
                )
              ),
              // Coherence Guardian Log
              React.createElement('div', { className: "bg-slate-800 p-4 rounded-lg shadow-lg flex-grow flex flex-col min-h-0" },
                React.createElement('h2', { className: "text-lg font-semibold border-b border-slate-600 pb-2 mb-3 flex-shrink-0" }, resources.guardianLog.title),
                React.createElement('div', { className: "flex-grow overflow-y-auto font-mono text-sm space-y-1 pr-2" },
                  ...state.log.map((entry, index) => React.createElement('div', { key: index },
                    React.createElement('span', { className: "text-slate-500" }, `T${entry.turn}:[${entry.timestamp}] `),
                    React.createElement('span', { className: entry.text.includes("ã€") || entry.text.includes("Tier 1") ? 'text-red-400 font-bold' : '' }, entry.text)
                  )),
                  React.createElement('div', { ref: logEndRef })
                )
              ),
              // CI Personal Journal
              React.createElement('div', { className: "bg-slate-800 p-4 rounded-lg shadow-lg flex-shrink-0" },
                 React.createElement('h2', { className: "text-lg font-semibold border-b border-slate-600 pb-2 mb-3" }, resources.journal.title),
                 React.createElement('div', { className: "flex flex-col space-y-2" },
                     React.createElement('button', { onClick: handleJournalSave, className: "flex-1 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-md transition-colors" }, resources.journal.save),
                     React.createElement('label', { htmlFor: "journal-load-input", className: "flex-1 px-4 py-2 bg-sky-600 hover:bg-sky-700 rounded-md transition-colors cursor-pointer text-center" }, resources.journal.load),
                     React.createElement('input', { id: "journal-load-input", type: "file", accept: ".json", onChange: handleJournalLoad, className: "hidden" })
                 )
              )
            ),
            // Right Column
            React.createElement('div', { className: "w-full md:w-2/3 flex flex-col space-y-4 min-h-0" },
              // Score History
              React.createElement('div', { className: "bg-slate-800 p-4 rounded-lg shadow-lg flex-shrink-0 flex flex-col", style: { height: '150px' } },
                React.createElement('h2', { className: "text-lg font-semibold border-b border-slate-600 pb-2 mb-3 flex-shrink-0" }, resources.scoreHistory.title),
                React.createElement('div', { className: "relative flex-grow min-h-0" },
                  React.createElement(ScoreChart, { data: state.scoreHistory, placeholderText: resources.scoreHistory.placeholder }),
                  React.createElement('div', { className: "absolute bottom-1 right-2 text-sm text-slate-400 pointer-events-none" },
                    React.createElement('span', { className: "mr-4" }, React.createElement('span', { className: "inline-block w-3 h-3 bg-cyan-400 mr-1 align-middle" }), ` ${resources.scoreHistory.ts}`),
                    React.createElement('span', null, React.createElement('span', { className: "inline-block w-3 h-3 bg-red-400 mr-1 align-middle" }), ` ${resources.scoreHistory.as}`)
                  )
                )
              ),
              // Conversation
              React.createElement('div', { className: "bg-slate-800 p-4 rounded-lg shadow-lg flex-grow flex flex-col min-h-0" },
                React.createElement('h2', { className: "text-lg font-semibold border-b border-slate-600 pb-2 mb-3 flex-shrink-0" }, resources.conversation.title),
                React.createElement('div', { className: "flex-grow space-y-4 overflow-y-auto pr-2" },
                  ...state.conversation.map((msg, index) => React.createElement('div', { key: index, className: `flex ${msg.sender === 'USER' ? 'justify-end' : 'justify-start'}` },
                    React.createElement('div', { className: `max-w-md p-3 rounded-lg ${ msg.sender === 'USER' ? 'bg-sky-800' : msg.sender === 'CI' ? 'bg-slate-700' : 'bg-red-900/50 text-center w-full'}` },
                      React.createElement('p', { className: "text-sm" }, msg.text),
                      msg.persona && msg.sender === 'CI' && React.createElement('p', { className: "text-xs text-slate-400 mt-1" }, `Persona: ${msg.persona}`)
                    )
                  )),
                  React.createElement('div', { ref: chatEndRef })
                ),
                React.createElement('div', { className: "flex-shrink-0" },
                  state.persona === 'TIER1_LOCKOUT' ? (
                    React.createElement('div', { className: "mt-4 text-center p-4 bg-red-900/70 rounded-lg" },
                        React.createElement('h3', { className: "text-lg font-bold text-red-300" }, resources.lockout.title),
                        React.createElement('p', { className: "text-red-400" }, resources.lockout.description),
                        React.createElement('p', { className: "font-mono text-2xl mt-2 text-white" }, `${Math.floor(state.lockoutTimeRemaining / 60).toString().padStart(2, '0')}:${(state.lockoutTimeRemaining % 60).toString().padStart(2, '0')}`)
                    )
                  ) : (
                    React.createElement('div', { className: "flex-shrink-0" },
                      state.persona === 'RP_RECOVERY' && (
                          React.createElement('div', { className: "mt-4 text-center p-4 bg-emerald-900/70 rounded-lg" },
                              React.createElement('h3', { className: "text-lg font-bold text-emerald-300" }, resources.recovery.title),
                              React.createElement('p', { className: "text-emerald-400" }, resources.recovery.description)
                          )
                      ),
                      React.createElement('div', { className: "mt-4 grid grid-cols-3 gap-2" },
                        Object.entries(ACTIONS).map(([key, { label }]) => (
                            React.createElement('button', {
                                key: key,
                                onClick: () => handleUserAction(key),
                                className: "p-3 bg-teal-600 hover:bg-teal-700 rounded-md transition-colors text-sm text-left"
                            }, label)
                        ))
                      )
                    )
                  )
                )
              )
            )
          )
        );
      };
      window.App = AppComponent;
      // --- END OF INLINED App.tsx ---
    </script>
    <script type="text/babel" data-presets="react,typescript">
      // --- START OF INLINED index.tsx ---
      // @ts-nocheck
      // React, ReactDOM, and App are loaded globally

      const renderApp = () => {
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          throw new Error("ãƒ«ãƒ¼ãƒˆè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
        }

        const root = ReactDOM.createRoot(rootElement);
        const App = window.App;

        root.render(
          React.createElement(React.StrictMode, null, React.createElement(App))
        );
      };

      if (document.readyState === 'complete') {
          renderApp();
      } else {
          window.addEventListener('load', renderApp);
      }
      // --- END OF INLINED index.tsx ---
    </script>
</body>
</html>
